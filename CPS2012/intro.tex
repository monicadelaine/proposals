\section{Introduction}
Robotic systems are an important class of cyber-physical systems. The ability of robots to interact intelligently with the world rests upon embedded computation and communication, real-time control, and perception of the world around them~\cite{Trinkle2008}. Integration of sensors and actuators into a single cohesive robotics system often requires a composition of service-based components that either produce, consume or transform information in a loosely coupled, parallel manner.

%Those wishing to create autonomous controllers either choose to develop software specifically for target hardware or choose to rely upon a framework that provides a link to the target hardware device.  In the first case, developers are forced to delve into the device specific interfaces that discourage all but the most hardware-inclined roboticist.  In the second case, researchers  work through a framework that not only provides some higher-level intelligent algorithms, but also drivers for popular devices.  However, the developer is constrained to the devices that have driver plugin available.  

Although robot controller developers can create a program to execute directly on a specific robot platform, frameworks are more often used as an intermediary between autonomous controllers and the hardware.    Controllers access and manipulate robots via application programming interfaces (API) that reflect a generalized model of the robot.  The APIs access robot-specific interfaces through device drivers.  This approach not only speeds development through reuse of code (code is not hardware  specific) but also facilitates the re-purposing of controllers to other hardware platforms.  Device drivers in this context act as a mechanism for mapping individual robot features to domain concepts.   Device drivers are usually implemented as processes that manage the hardware connection for the framework while translating requests for data and action from the framework into formatted message requests and responses.   Although some increases in latency are experienced with multiple levels of indirection, it is often considered trivial compared to the time investment of attempting to develop and debug remote applications or retrofitting algorithms for varying hardware platform configurations.

There are some opportunities inherent in this approach.   Some would say that device driver development is complex.  It is probably true that writing reasonable performing device drivers (like all embedded development) requires an understanding of hardware, timing issues, threading, process synchronization, performance tuning and the operating system of the driver host system.  However, good examples exist within frameworks and development of reasonable drivers is not prohibitive in terms of skill set.   A more pressing issue concerns the multiplicity involved in creating device drivers.  As device drivers provide a programmed link between hardware and frameworks, custom drivers have to be created for each framework hardware pair.  Although some robot frameworks enjoy more popularity than others, many frameworks are routinely used within the robotics research and education community.   An additional challenge is that while there are groups that focus on framework development, in house driver support for existing platforms is usually limited to a few popular platforms and certainly does not include any custom platforms or configurations.  Robot manufacturers typically provide device drivers for a subset of "supported" frameworks.

Addressing the issue of needing one-to-one mappings between frameworks and devices can introduce some efficiencies and additional flexibility that robotics developers do not currently have.  However there is a bigger issue at stake.  Although there are many innovations from software engineering that have been utilized successfully within robotics architectures, there is a notable exception when it comes to identifying the system of record for device syntax and semantics.  In the context of robotics, it is this failure that results in major duplication in integrating hardware devices into autonomous controllers.   Moreover the more important opportunity in making the hardware the system of record for its syntax and semantics is the ability to discover services and provide a component wrapper around devices that allows for composition of intelligent software.

%Given that the device drivers primarily are a map between the hardware API and the framework API, there is an opportunity to provide this mapping declaratively rather than as a program.  Rather than require developers possess expertise in both hardware devices and autonomy, the use of a hardware description language that captures the manufacturer invariant properties of how to use on-board services and what the semantics of the provided information mean can allow for discovery at development time and provide a runtime environment.  

RDIS (Robot Device Interface Specification) \cite{Anderson2012} is a domain-specific language (DSL) that captures the syntax and semantics of hardware devices with embedded controller managed external interfaces.  This declarative description captures the manufacturer invariant interface made available by firmware in terms of transports and messages and how they map to domain specific concepts.  RDIS is currently a preliminary prototype that supports a limited set of processing models and domain concepts.  The work proposed as part of this effort will accomplish the following major innovations to RDIS as a contribution to the engineering of cyber-physical systems: 1) extend the processing models to include a larger set of {\bf execution semantics}, 2) extend the actuation model to include a larger set of {\bf popular kinematic chains} from both manufacturing and exploration robotics, and 3) create a supporting set of tools and frameworks that supports {\bf prototyping, evaluation and adoption}.

Hardware that can communicate its capabilities and programming API to a general programming tool would offload the knowledge of the hardware to the system of origin (the correct system of record).  This aspect of the proposed project is {\bf transformative} and directly impacts the {\bf engineering of cyber-physical systems}; it could potentially affect the creation of new hardware platforms, reduce the complexity of device drivers (encourage new devices) and lower the learning curve to working with platforms.  This project accomplishes a {\bf breakthrough} using the intersection of software engineering and embedded systems.  RDIS describes available services much like web-based services while also providing transport and timing specific details.  While this breakthrough proposal concerns itself primarily with robotics devices (those that provide sensor information or actuation), it is expected that the process and principles developed here will be generalizable to sensors and actuators in other domains (i.e. car sensors, etc).  Interactive design has bought new energy and rigor to fabrication and hardware prototyping.  Incorporating interactive design principles into robotics software tools would encourage software prototyping and experimentation, providing learning experiences in computational thinking, computer science and robotics.  



